import axios__default from 'axios';
import { format, parse } from 'url';
import crypto from 'crypto';

var name = "@monei-js/node-sdk";
var description = "Node.js SDK for MONEI Digital Payment Gateway";
var version = "1.4.4";
var homepage = "https://monei.com";
var author = "MONEI <support@monei.com> (https://monei.com)";
var license = "MIT";
var contributors = [
	"Dmitriy Nevzorov <dn@monei.com>"
];
var repository = {
	type: "git",
	url: "https://github.com/MONEI/monei-node-sdk"
};
var keywords = [
	"monei",
	"payment gateway",
	"payment processing",
	"credit cards",
	"api"
];
var source = "./monei.ts";
var main = "dist/monei.js";
var module = "dist/monei.module.js";
var types = "dist/monei.d.ts";
var publishConfig = {
	access: "public",
	registry: "https://registry.npmjs.org/"
};
var scripts = {
	generate: "openapi-generator generate -i https://js.monei.com/api/v1/openapi.json -g typescript-axios --remove-operation-id-prefix -c ./config.json -o ./src",
	"generate:local": "openapi-generator generate -i ./openapi.json -g typescript-axios --remove-operation-id-prefix -c ./config.json -o ./src",
	compile: "microbundle -f es,cjs --target node --strict",
	dev: "microbundle watch  -f es,cjs --target node --strict",
	build: "yarn generate && yarn replace && yarn compile",
	replace: "node replace.js",
	release: "release-it",
	prepare: "yarn run build",
	test: "jest"
};
var devDependencies = {
	"@openapitools/openapi-generator-cli": "^1.0.18-4.3.1",
	"@types/node": "^14.11.2",
	dotenv: "^8.2.0",
	jest: "^26.5.3",
	microbundle: "^0.12.3",
	prettier: "^2.1.2",
	"release-it": "^14.0.3",
	"replace-in-file": "^6.1.0",
	"ts-jest": "^26.4.1"
};
var dependencies = {
	axios: "^0.21.1"
};
var jest = {
	moduleFileExtensions: [
		"ts",
		"js"
	],
	transform: {
		"\\.ts$": "ts-jest"
	},
	testMatch: [
		"**/*.test.ts"
	]
};
var pkg = {
	name: name,
	description: description,
	version: version,
	homepage: homepage,
	author: author,
	license: license,
	contributors: contributors,
	repository: repository,
	keywords: keywords,
	source: source,
	main: main,
	module: module,
	types: types,
	publishConfig: publishConfig,
	scripts: scripts,
	devDependencies: devDependencies,
	dependencies: dependencies,
	jest: jest,
	"release-it": {
	git: {
		tagName: "v${version}",
		commitMessage: "chore: release v${version}"
	},
	github: {
		release: true
	},
	npm: {
		publish: true
	},
	hooks: {
		"before:init": [
			"yarn test"
		]
	}
}
};

function _extends() {
  _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  return _extends.apply(this, arguments);
}

// tslint:disable
const BASE_PATH = "https://api.monei.com/v1".replace(/\/+$/, "");
/**
 *
 * @export
 * @class BaseAPI
 */

class BaseAPI {
  constructor(configuration, basePath = BASE_PATH, axios = axios__default) {
    this.basePath = basePath;
    this.axios = axios;

    if (configuration) {
      this.configuration = configuration;
      this.basePath = configuration.basePath || this.basePath;
    }
  }

}
/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */

class RequiredError extends Error {
  constructor(field, msg) {
    super(msg);
    this.field = field;
    this.name = "RequiredError";
  }

}

/**
 * The reason for canceling the Payment.
 * @export
 * @enum {string}
 */

var PaymentCancellationReason;

(function (PaymentCancellationReason) {
  PaymentCancellationReason["duplicated"] = "duplicated";
  PaymentCancellationReason["fraudulent"] = "fraudulent";
  PaymentCancellationReason["requested_by_customer"] = "requested_by_customer";
})(PaymentCancellationReason || (PaymentCancellationReason = {}));
/**
 * The reason of the last refund transaction.
 * @export
 * @enum {string}
 */


var PaymentLastRefundReason;

(function (PaymentLastRefundReason) {
  PaymentLastRefundReason["duplicated"] = "duplicated";
  PaymentLastRefundReason["fraudulent"] = "fraudulent";
  PaymentLastRefundReason["requested_by_customer"] = "requested_by_customer";
})(PaymentLastRefundReason || (PaymentLastRefundReason = {}));
/**
 * The channel used to send the payment message.
 * @export
 * @enum {string}
 */


var PaymentMessageChannel;

(function (PaymentMessageChannel) {
  PaymentMessageChannel["EMAIL"] = "EMAIL";
  PaymentMessageChannel["WHATSAPP"] = "WHATSAPP";
  PaymentMessageChannel["SMS"] = "SMS";
})(PaymentMessageChannel || (PaymentMessageChannel = {}));
/**
 * The language of message sent to the customer. If not provided the default customer language is used if available.
 * @export
 * @enum {string}
 */


var PaymentMessageLanguage;

(function (PaymentMessageLanguage) {
  PaymentMessageLanguage["en"] = "en";
  PaymentMessageLanguage["es"] = "es";
  PaymentMessageLanguage["ca"] = "ca";
  PaymentMessageLanguage["pt"] = "pt";
  PaymentMessageLanguage["de"] = "de";
  PaymentMessageLanguage["it"] = "it";
  PaymentMessageLanguage["fr"] = "fr";
})(PaymentMessageLanguage || (PaymentMessageLanguage = {}));
/**
    * @export
    * @enum {string}
    */


var PaymentNextActionTypeEnum;

(function (PaymentNextActionTypeEnum) {
  PaymentNextActionTypeEnum["CONFIRM"] = "CONFIRM";
  PaymentNextActionTypeEnum["CHALLENGE"] = "CHALLENGE";
  PaymentNextActionTypeEnum["FRICTIONLESS_CHALLENGE"] = "FRICTIONLESS_CHALLENGE";
  PaymentNextActionTypeEnum["BIZUM_CHALLENGE"] = "BIZUM_CHALLENGE";
  PaymentNextActionTypeEnum["COMPLETE"] = "COMPLETE";
})(PaymentNextActionTypeEnum || (PaymentNextActionTypeEnum = {}));
/**
    * @export
    * @enum {string}
    */


var PaymentPaymentMethodMethodEnum;

(function (PaymentPaymentMethodMethodEnum) {
  PaymentPaymentMethodMethodEnum["card"] = "card";
  PaymentPaymentMethodMethodEnum["bizum"] = "bizum";
  PaymentPaymentMethodMethodEnum["googlePay"] = "googlePay";
  PaymentPaymentMethodMethodEnum["applePay"] = "applePay";
  PaymentPaymentMethodMethodEnum["clickToPay"] = "clickToPay";
  PaymentPaymentMethodMethodEnum["paypal"] = "paypal";
  PaymentPaymentMethodMethodEnum["cofidis"] = "cofidis";
  PaymentPaymentMethodMethodEnum["cofidisLoan"] = "cofidisLoan";
  PaymentPaymentMethodMethodEnum["iDeal"] = "iDeal";
  PaymentPaymentMethodMethodEnum["mbway"] = "mbway";
  PaymentPaymentMethodMethodEnum["multibanco"] = "multibanco";
  PaymentPaymentMethodMethodEnum["sofort"] = "sofort";
  PaymentPaymentMethodMethodEnum["trustly"] = "trustly";
  PaymentPaymentMethodMethodEnum["sepa"] = "sepa";
  PaymentPaymentMethodMethodEnum["klarna"] = "klarna";
  PaymentPaymentMethodMethodEnum["giropay"] = "giropay";
})(PaymentPaymentMethodMethodEnum || (PaymentPaymentMethodMethodEnum = {}));
/**
    * @export
    * @enum {string}
    */


var PaymentPaymentMethodCardBrandEnum;

(function (PaymentPaymentMethodCardBrandEnum) {
  PaymentPaymentMethodCardBrandEnum["visa"] = "visa";
  PaymentPaymentMethodCardBrandEnum["mastercard"] = "mastercard";
  PaymentPaymentMethodCardBrandEnum["diners"] = "diners";
  PaymentPaymentMethodCardBrandEnum["amex"] = "amex";
  PaymentPaymentMethodCardBrandEnum["jcb"] = "jcb";
  PaymentPaymentMethodCardBrandEnum["unionpay"] = "unionpay";
  PaymentPaymentMethodCardBrandEnum["unknown"] = "unknown";
})(PaymentPaymentMethodCardBrandEnum || (PaymentPaymentMethodCardBrandEnum = {}));
/**
    * @export
    * @enum {string}
    */


var PaymentPaymentMethodCardTypeEnum;

(function (PaymentPaymentMethodCardTypeEnum) {
  PaymentPaymentMethodCardTypeEnum["debit"] = "debit";
  PaymentPaymentMethodCardTypeEnum["credit"] = "credit";
})(PaymentPaymentMethodCardTypeEnum || (PaymentPaymentMethodCardTypeEnum = {}));
/**
    * @export
    * @enum {string}
    */


var PaymentPaymentMethodCardThreeDSecureFlowEnum;

(function (PaymentPaymentMethodCardThreeDSecureFlowEnum) {
  PaymentPaymentMethodCardThreeDSecureFlowEnum["CHALLENGE"] = "CHALLENGE";
  PaymentPaymentMethodCardThreeDSecureFlowEnum["FRICTIONLESS"] = "FRICTIONLESS";
  PaymentPaymentMethodCardThreeDSecureFlowEnum["FRICTIONLESS_CHALLENGE"] = "FRICTIONLESS_CHALLENGE";
  PaymentPaymentMethodCardThreeDSecureFlowEnum["DIRECT"] = "DIRECT";
})(PaymentPaymentMethodCardThreeDSecureFlowEnum || (PaymentPaymentMethodCardThreeDSecureFlowEnum = {}));
/**
    * @export
    * @enum {string}
    */


var PaymentPaymentMethodCardTokenizationMethodEnum;

(function (PaymentPaymentMethodCardTokenizationMethodEnum) {
  PaymentPaymentMethodCardTokenizationMethodEnum["applePay"] = "applePay";
  PaymentPaymentMethodCardTokenizationMethodEnum["googlePay"] = "googlePay";
  PaymentPaymentMethodCardTokenizationMethodEnum["clickToPay"] = "clickToPay";
})(PaymentPaymentMethodCardTokenizationMethodEnum || (PaymentPaymentMethodCardTokenizationMethodEnum = {}));
/**
    * @export
    * @enum {string}
    */


var PaymentPaymentMethodKlarnaBillingCategoryEnum;

(function (PaymentPaymentMethodKlarnaBillingCategoryEnum) {
  PaymentPaymentMethodKlarnaBillingCategoryEnum["PAY_LATER"] = "PAY_LATER";
  PaymentPaymentMethodKlarnaBillingCategoryEnum["PAY_NOW"] = "PAY_NOW";
  PaymentPaymentMethodKlarnaBillingCategoryEnum["SLICE_IT"] = "SLICE_IT";
  PaymentPaymentMethodKlarnaBillingCategoryEnum["SLICE_IT_BY_CARD"] = "SLICE_IT_BY_CARD";
})(PaymentPaymentMethodKlarnaBillingCategoryEnum || (PaymentPaymentMethodKlarnaBillingCategoryEnum = {}));
/**
    * @export
    * @enum {string}
    */


var PaymentPaymentMethodKlarnaAuthPaymentMethodEnum;

(function (PaymentPaymentMethodKlarnaAuthPaymentMethodEnum) {
  PaymentPaymentMethodKlarnaAuthPaymentMethodEnum["invoice"] = "invoice";
  PaymentPaymentMethodKlarnaAuthPaymentMethodEnum["fixed_amount"] = "fixed_amount";
  PaymentPaymentMethodKlarnaAuthPaymentMethodEnum["pix"] = "pix";
  PaymentPaymentMethodKlarnaAuthPaymentMethodEnum["base_account"] = "base_account";
  PaymentPaymentMethodKlarnaAuthPaymentMethodEnum["deferred_interest"] = "deferred_interest";
  PaymentPaymentMethodKlarnaAuthPaymentMethodEnum["direct_debit"] = "direct_debit";
  PaymentPaymentMethodKlarnaAuthPaymentMethodEnum["direct_bank_transfer"] = "direct_bank_transfer";
  PaymentPaymentMethodKlarnaAuthPaymentMethodEnum["b2b_invoice"] = "b2b_invoice";
  PaymentPaymentMethodKlarnaAuthPaymentMethodEnum["card"] = "card";
  PaymentPaymentMethodKlarnaAuthPaymentMethodEnum["slice_it_by_card"] = "slice_it_by_card";
})(PaymentPaymentMethodKlarnaAuthPaymentMethodEnum || (PaymentPaymentMethodKlarnaAuthPaymentMethodEnum = {}));
/**
 * The reason for refunding the Payment.
 * @export
 * @enum {string}
 */


var PaymentRefundReason;

(function (PaymentRefundReason) {
  PaymentRefundReason["duplicated"] = "duplicated";
  PaymentRefundReason["fraudulent"] = "fraudulent";
  PaymentRefundReason["requested_by_customer"] = "requested_by_customer";
})(PaymentRefundReason || (PaymentRefundReason = {}));
/**
    * @export
    * @enum {string}
    */


var PaymentSequenceTypeEnum;

(function (PaymentSequenceTypeEnum) {
  PaymentSequenceTypeEnum["recurring"] = "recurring";
})(PaymentSequenceTypeEnum || (PaymentSequenceTypeEnum = {}));
/**
 * The status of the payment.
 * @export
 * @enum {string}
 */


var PaymentStatus;

(function (PaymentStatus) {
  PaymentStatus["SUCCEEDED"] = "SUCCEEDED";
  PaymentStatus["PENDING"] = "PENDING";
  PaymentStatus["FAILED"] = "FAILED";
  PaymentStatus["CANCELED"] = "CANCELED";
  PaymentStatus["REFUNDED"] = "REFUNDED";
  PaymentStatus["PARTIALLY_REFUNDED"] = "PARTIALLY_REFUNDED";
  PaymentStatus["AUTHORIZED"] = "AUTHORIZED";
  PaymentStatus["EXPIRED"] = "EXPIRED";
})(PaymentStatus || (PaymentStatus = {}));
/**
 * Controls when the funds will be captured.   - `SALE` - **Default**. MONEI automatically captures funds     when the customer authorizes the payment.   - `AUTH` - Place a hold on the funds when the customer authorizes     the payment, but don’t capture the funds until later.   - `PAYOUT` - Send funds to the customer   - `VERIF` - Verify the card without placing a hold or capturing funds.
 * @export
 * @enum {string}
 */


var PaymentTransactionType;

(function (PaymentTransactionType) {
  PaymentTransactionType["SALE"] = "SALE";
  PaymentTransactionType["AUTH"] = "AUTH";
  PaymentTransactionType["PAYOUT"] = "PAYOUT";
  PaymentTransactionType["VERIF"] = "VERIF";
})(PaymentTransactionType || (PaymentTransactionType = {}));
/**
 * Subscription interval.
 * @export
 * @enum {string}
 */


var SubscriptionInterval;

(function (SubscriptionInterval) {
  SubscriptionInterval["day"] = "day";
  SubscriptionInterval["week"] = "week";
  SubscriptionInterval["month"] = "month";
  SubscriptionInterval["year"] = "year";
})(SubscriptionInterval || (SubscriptionInterval = {}));
/**
    * @export
    * @enum {string}
    */


var SubscriptionPaymentMethodMethodEnum;

(function (SubscriptionPaymentMethodMethodEnum) {
  SubscriptionPaymentMethodMethodEnum["card"] = "card";
})(SubscriptionPaymentMethodMethodEnum || (SubscriptionPaymentMethodMethodEnum = {}));
/**
    * @export
    * @enum {string}
    */


var SubscriptionPaymentMethodCardBrandEnum;

(function (SubscriptionPaymentMethodCardBrandEnum) {
  SubscriptionPaymentMethodCardBrandEnum["visa"] = "visa";
  SubscriptionPaymentMethodCardBrandEnum["mastercard"] = "mastercard";
  SubscriptionPaymentMethodCardBrandEnum["diners"] = "diners";
  SubscriptionPaymentMethodCardBrandEnum["amex"] = "amex";
  SubscriptionPaymentMethodCardBrandEnum["jcb"] = "jcb";
  SubscriptionPaymentMethodCardBrandEnum["unionpay"] = "unionpay";
  SubscriptionPaymentMethodCardBrandEnum["unknown"] = "unknown";
})(SubscriptionPaymentMethodCardBrandEnum || (SubscriptionPaymentMethodCardBrandEnum = {}));
/**
    * @export
    * @enum {string}
    */


var SubscriptionPaymentMethodCardTypeEnum;

(function (SubscriptionPaymentMethodCardTypeEnum) {
  SubscriptionPaymentMethodCardTypeEnum["debit"] = "debit";
  SubscriptionPaymentMethodCardTypeEnum["credit"] = "credit";
})(SubscriptionPaymentMethodCardTypeEnum || (SubscriptionPaymentMethodCardTypeEnum = {}));
/**
 * The status of the subscription.
 * @export
 * @enum {string}
 */


var SubscriptionStatus;

(function (SubscriptionStatus) {
  SubscriptionStatus["PENDING"] = "PENDING";
  SubscriptionStatus["EXPIRED"] = "EXPIRED";
  SubscriptionStatus["TRIALING"] = "TRIALING";
  SubscriptionStatus["ACTIVE"] = "ACTIVE";
  SubscriptionStatus["PAST_DUE"] = "PAST_DUE";
  SubscriptionStatus["PAUSED"] = "PAUSED";
  SubscriptionStatus["CANCELED"] = "CANCELED";
})(SubscriptionStatus || (SubscriptionStatus = {}));
/**
 * ApplePayDomainApi - axios parameter creator
 * @export
 */


const ApplePayDomainApiAxiosParamCreator = function (configuration) {
  return {
    /**
     * <p>Registers custom domain for Apple Pay.</p> <p>Download this <a href=\"https://assets.monei.com/apple-pay/apple-developer-merchantid-domain-association/\">domain association file</a> and host it at <code>/.well-known/apple-developer-merchantid-domain-association</code> on your site.</p> <p>For example, if you’re registering <code>example.com</code>, make that file available at <code>https://example.com/.well-known/apple-developer-merchantid-domain-association</code>.</p>
     * @summary Register
     * @param {RegisterDomainRequest} registerDomainRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    register: function (registerDomainRequest, options = {}) {
      try {
        function _temp2() {
          localVarHeaderParameter['Content-Type'] = 'application/json';
          localVarUrlObj.query = _extends({}, localVarUrlObj.query, localVarQueryParameter, options.query); // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943

          delete localVarUrlObj.search;
          let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
          localVarRequestOptions.headers = _extends({}, localVarHeaderParameter, headersFromBaseOptions, options.headers);
          const needsSerialization = typeof registerDomainRequest !== "string" || localVarRequestOptions.headers['Content-Type'] === 'application/json';
          localVarRequestOptions.data = needsSerialization ? JSON.stringify(registerDomainRequest !== undefined ? registerDomainRequest : {}) : registerDomainRequest || "";
          return {
            url: format(localVarUrlObj),
            options: localVarRequestOptions
          };
        }

        // verify required parameter 'registerDomainRequest' is not null or undefined
        if (registerDomainRequest === null || registerDomainRequest === undefined) {
          throw new RequiredError('registerDomainRequest', 'Required parameter registerDomainRequest was null or undefined when calling register.');
        }

        const localVarPath = `/apple-pay/domains`;
        const localVarUrlObj = parse(localVarPath, true);
        let baseOptions;

        if (configuration) {
          baseOptions = configuration.baseOptions;
        }

        const localVarRequestOptions = _extends({
          method: 'POST'
        }, baseOptions, options);

        const localVarHeaderParameter = {};
        const localVarQueryParameter = {}; // authentication APIKey required

        const _temp = function () {
          if (configuration && configuration.apiKey) {
            return Promise.resolve(typeof configuration.apiKey === 'function' ? configuration.apiKey("Authorization") : configuration.apiKey).then(function (localVarApiKeyValue) {
              localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            });
          }
        }();

        return Promise.resolve(_temp && _temp.then ? _temp.then(_temp2) : _temp2(_temp));
      } catch (e) {
        return Promise.reject(e);
      }
    }
  };
};
/**
 * ApplePayDomainApi - functional programming interface
 * @export
 */

const ApplePayDomainApiFp = function (configuration) {
  return {
    /**
     * <p>Registers custom domain for Apple Pay.</p> <p>Download this <a href=\"https://assets.monei.com/apple-pay/apple-developer-merchantid-domain-association/\">domain association file</a> and host it at <code>/.well-known/apple-developer-merchantid-domain-association</code> on your site.</p> <p>For example, if you’re registering <code>example.com</code>, make that file available at <code>https://example.com/.well-known/apple-developer-merchantid-domain-association</code>.</p>
     * @summary Register
     * @param {RegisterDomainRequest} registerDomainRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    register: function (registerDomainRequest, options) {
      try {
        return Promise.resolve(ApplePayDomainApiAxiosParamCreator(configuration).register(registerDomainRequest, options)).then(function (localVarAxiosArgs) {
          return (axios = axios__default, basePath = BASE_PATH) => {
            const axiosRequestArgs = _extends({}, localVarAxiosArgs.options, {
              url: basePath + localVarAxiosArgs.url
            });

            return axios.request(axiosRequestArgs);
          };
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
  };
};
/**
 * ApplePayDomainApi - factory interface
 * @export
 */

const ApplePayDomainApiFactory = function (configuration, basePath, axios) {
  return {
    /**
     * <p>Registers custom domain for Apple Pay.</p> <p>Download this <a href=\"https://assets.monei.com/apple-pay/apple-developer-merchantid-domain-association/\">domain association file</a> and host it at <code>/.well-known/apple-developer-merchantid-domain-association</code> on your site.</p> <p>For example, if you’re registering <code>example.com</code>, make that file available at <code>https://example.com/.well-known/apple-developer-merchantid-domain-association</code>.</p>
     * @summary Register
     * @param {RegisterDomainRequest} registerDomainRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    register(registerDomainRequest, options) {
      return ApplePayDomainApiFp(configuration).register(registerDomainRequest, options).then(request => request(axios, basePath));
    }

  };
};
/**
 * ApplePayDomainApi - object-oriented interface
 * @export
 * @class ApplePayDomainApi
 * @extends {BaseAPI}
 */

class ApplePayDomainApi extends BaseAPI {
  /**
   * <p>Registers custom domain for Apple Pay.</p> <p>Download this <a href=\"https://assets.monei.com/apple-pay/apple-developer-merchantid-domain-association/\">domain association file</a> and host it at <code>/.well-known/apple-developer-merchantid-domain-association</code> on your site.</p> <p>For example, if you’re registering <code>example.com</code>, make that file available at <code>https://example.com/.well-known/apple-developer-merchantid-domain-association</code>.</p>
   * @summary Register
   * @param {RegisterDomainRequest} registerDomainRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof ApplePayDomainApi
   */
  register(registerDomainRequest, options) {
    return ApplePayDomainApiFp(this.configuration).register(registerDomainRequest, options).then(request => request(this.axios, this.basePath));
  }

}
/**
 * BizumApi - axios parameter creator
 * @export
 */

const BizumApiAxiosParamCreator = function (configuration) {
  return {
    /**
     * <p>Verifies if the provided phone number is registered in Bizum. This method does not require authentication. Either <code>accountId</code> or <code>paymentId</code> must be provided in the request body.</p>
     * @summary Validate Phone
     * @param {ValidateBizumPhoneRequest} validateBizumPhoneRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    validatePhone: function (validateBizumPhoneRequest, options = {}) {
      try {
        // verify required parameter 'validateBizumPhoneRequest' is not null or undefined
        if (validateBizumPhoneRequest === null || validateBizumPhoneRequest === undefined) {
          throw new RequiredError('validateBizumPhoneRequest', 'Required parameter validateBizumPhoneRequest was null or undefined when calling validatePhone.');
        }

        const localVarPath = `/bizum/validate-phone`;
        const localVarUrlObj = parse(localVarPath, true);
        let baseOptions;

        if (configuration) {
          baseOptions = configuration.baseOptions;
        }

        const localVarRequestOptions = _extends({
          method: 'POST'
        }, baseOptions, options);

        const localVarHeaderParameter = {};
        const localVarQueryParameter = {};
        localVarHeaderParameter['Content-Type'] = 'application/json';
        localVarUrlObj.query = _extends({}, localVarUrlObj.query, localVarQueryParameter, options.query); // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943

        delete localVarUrlObj.search;
        let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
        localVarRequestOptions.headers = _extends({}, localVarHeaderParameter, headersFromBaseOptions, options.headers);
        const needsSerialization = typeof validateBizumPhoneRequest !== "string" || localVarRequestOptions.headers['Content-Type'] === 'application/json';
        localVarRequestOptions.data = needsSerialization ? JSON.stringify(validateBizumPhoneRequest !== undefined ? validateBizumPhoneRequest : {}) : validateBizumPhoneRequest || "";
        return Promise.resolve({
          url: format(localVarUrlObj),
          options: localVarRequestOptions
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
  };
};
/**
 * BizumApi - functional programming interface
 * @export
 */

const BizumApiFp = function (configuration) {
  return {
    /**
     * <p>Verifies if the provided phone number is registered in Bizum. This method does not require authentication. Either <code>accountId</code> or <code>paymentId</code> must be provided in the request body.</p>
     * @summary Validate Phone
     * @param {ValidateBizumPhoneRequest} validateBizumPhoneRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    validatePhone: function (validateBizumPhoneRequest, options) {
      try {
        return Promise.resolve(BizumApiAxiosParamCreator(configuration).validatePhone(validateBizumPhoneRequest, options)).then(function (localVarAxiosArgs) {
          return (axios = axios__default, basePath = BASE_PATH) => {
            const axiosRequestArgs = _extends({}, localVarAxiosArgs.options, {
              url: basePath + localVarAxiosArgs.url
            });

            return axios.request(axiosRequestArgs);
          };
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
  };
};
/**
 * BizumApi - factory interface
 * @export
 */

const BizumApiFactory = function (configuration, basePath, axios) {
  return {
    /**
     * <p>Verifies if the provided phone number is registered in Bizum. This method does not require authentication. Either <code>accountId</code> or <code>paymentId</code> must be provided in the request body.</p>
     * @summary Validate Phone
     * @param {ValidateBizumPhoneRequest} validateBizumPhoneRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    validatePhone(validateBizumPhoneRequest, options) {
      return BizumApiFp(configuration).validatePhone(validateBizumPhoneRequest, options).then(request => request(axios, basePath));
    }

  };
};
/**
 * BizumApi - object-oriented interface
 * @export
 * @class BizumApi
 * @extends {BaseAPI}
 */

class BizumApi extends BaseAPI {
  /**
   * <p>Verifies if the provided phone number is registered in Bizum. This method does not require authentication. Either <code>accountId</code> or <code>paymentId</code> must be provided in the request body.</p>
   * @summary Validate Phone
   * @param {ValidateBizumPhoneRequest} validateBizumPhoneRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BizumApi
   */
  validatePhone(validateBizumPhoneRequest, options) {
    return BizumApiFp(this.configuration).validatePhone(validateBizumPhoneRequest, options).then(request => request(this.axios, this.basePath));
  }

}
/**
 * PaymentsApi - axios parameter creator
 * @export
 */

const PaymentsApiAxiosParamCreator = function (configuration) {
  return {
    /**
     * Release customer\'s funds that were reserved earlier. You can only cancel a payment with the `AUTHORIZED` status.  This is the second half of the two-step payment flow, where first you created a payment with the `transactionType` set to `AUTH`.
     * @summary Cancel Payment
     * @param {string} id The payment ID
     * @param {CancelPaymentRequest} [cancelPaymentRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancel: function (id, cancelPaymentRequest, options = {}) {
      try {
        function _temp4() {
          localVarHeaderParameter['Content-Type'] = 'application/json';
          localVarUrlObj.query = _extends({}, localVarUrlObj.query, localVarQueryParameter, options.query); // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943

          delete localVarUrlObj.search;
          let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
          localVarRequestOptions.headers = _extends({}, localVarHeaderParameter, headersFromBaseOptions, options.headers);
          const needsSerialization = typeof cancelPaymentRequest !== "string" || localVarRequestOptions.headers['Content-Type'] === 'application/json';
          localVarRequestOptions.data = needsSerialization ? JSON.stringify(cancelPaymentRequest !== undefined ? cancelPaymentRequest : {}) : cancelPaymentRequest || "";
          return {
            url: format(localVarUrlObj),
            options: localVarRequestOptions
          };
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
          throw new RequiredError('id', 'Required parameter id was null or undefined when calling cancel.');
        }

        const localVarPath = `/payments/{id}/cancel`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
        const localVarUrlObj = parse(localVarPath, true);
        let baseOptions;

        if (configuration) {
          baseOptions = configuration.baseOptions;
        }

        const localVarRequestOptions = _extends({
          method: 'POST'
        }, baseOptions, options);

        const localVarHeaderParameter = {};
        const localVarQueryParameter = {}; // authentication APIKey required

        const _temp3 = function () {
          if (configuration && configuration.apiKey) {
            return Promise.resolve(typeof configuration.apiKey === 'function' ? configuration.apiKey("Authorization") : configuration.apiKey).then(function (localVarApiKeyValue) {
              localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            });
          }
        }();

        return Promise.resolve(_temp3 && _temp3.then ? _temp3.then(_temp4) : _temp4(_temp3));
      } catch (e) {
        return Promise.reject(e);
      }
    },

    /**
     * Capture the payment of an existing, uncaptured, payment. This is the second half of the two-step payment flow, where first you created a payment with the `transactionType` set to `AUTH`.  Uncaptured payments expire exactly seven days after they are created. If they are not captured by that point in time, they will be marked as expired and will no longer be capturable.
     * @summary Capture Payment
     * @param {string} id The payment ID
     * @param {CapturePaymentRequest} [capturePaymentRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    capture: function (id, capturePaymentRequest, options = {}) {
      try {
        function _temp6() {
          localVarHeaderParameter['Content-Type'] = 'application/json';
          localVarUrlObj.query = _extends({}, localVarUrlObj.query, localVarQueryParameter, options.query); // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943

          delete localVarUrlObj.search;
          let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
          localVarRequestOptions.headers = _extends({}, localVarHeaderParameter, headersFromBaseOptions, options.headers);
          const needsSerialization = typeof capturePaymentRequest !== "string" || localVarRequestOptions.headers['Content-Type'] === 'application/json';
          localVarRequestOptions.data = needsSerialization ? JSON.stringify(capturePaymentRequest !== undefined ? capturePaymentRequest : {}) : capturePaymentRequest || "";
          return {
            url: format(localVarUrlObj),
            options: localVarRequestOptions
          };
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
          throw new RequiredError('id', 'Required parameter id was null or undefined when calling capture.');
        }

        const localVarPath = `/payments/{id}/capture`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
        const localVarUrlObj = parse(localVarPath, true);
        let baseOptions;

        if (configuration) {
          baseOptions = configuration.baseOptions;
        }

        const localVarRequestOptions = _extends({
          method: 'POST'
        }, baseOptions, options);

        const localVarHeaderParameter = {};
        const localVarQueryParameter = {}; // authentication APIKey required

        const _temp5 = function () {
          if (configuration && configuration.apiKey) {
            return Promise.resolve(typeof configuration.apiKey === 'function' ? configuration.apiKey("Authorization") : configuration.apiKey).then(function (localVarApiKeyValue) {
              localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            });
          }
        }();

        return Promise.resolve(_temp5 && _temp5.then ? _temp5.then(_temp6) : _temp6(_temp5));
      } catch (e) {
        return Promise.reject(e);
      }
    },

    /**
     * Confirm a payment that was created without a `paymentToken` or `paymentMethod`. You can only confirm a payment with the `PENDING` status.  You can charge a customer in two steps. First create a payment without payment details and then confirm it after you generate a `paymentToken` on the front-end with monei.js [Components](https://docs.monei.com/docs/monei-js-overview).  You can provide additional customer information, it will override the information passed in **create payment** request.
     * @summary Confirm Payment
     * @param {string} id The payment ID
     * @param {ConfirmPaymentRequest} [confirmPaymentRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    confirm: function (id, confirmPaymentRequest, options = {}) {
      try {
        function _temp8() {
          localVarHeaderParameter['Content-Type'] = 'application/json';
          localVarUrlObj.query = _extends({}, localVarUrlObj.query, localVarQueryParameter, options.query); // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943

          delete localVarUrlObj.search;
          let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
          localVarRequestOptions.headers = _extends({}, localVarHeaderParameter, headersFromBaseOptions, options.headers);
          const needsSerialization = typeof confirmPaymentRequest !== "string" || localVarRequestOptions.headers['Content-Type'] === 'application/json';
          localVarRequestOptions.data = needsSerialization ? JSON.stringify(confirmPaymentRequest !== undefined ? confirmPaymentRequest : {}) : confirmPaymentRequest || "";
          return {
            url: format(localVarUrlObj),
            options: localVarRequestOptions
          };
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
          throw new RequiredError('id', 'Required parameter id was null or undefined when calling confirm.');
        }

        const localVarPath = `/payments/{id}/confirm`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
        const localVarUrlObj = parse(localVarPath, true);
        let baseOptions;

        if (configuration) {
          baseOptions = configuration.baseOptions;
        }

        const localVarRequestOptions = _extends({
          method: 'POST'
        }, baseOptions, options);

        const localVarHeaderParameter = {};
        const localVarQueryParameter = {}; // authentication APIKey required

        const _temp7 = function () {
          if (configuration && configuration.apiKey) {
            return Promise.resolve(typeof configuration.apiKey === 'function' ? configuration.apiKey("Authorization") : configuration.apiKey).then(function (localVarApiKeyValue) {
              localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            });
          }
        }();

        return Promise.resolve(_temp7 && _temp7.then ? _temp7.then(_temp8) : _temp8(_temp7));
      } catch (e) {
        return Promise.reject(e);
      }
    },

    /**
     * To charge a credit card or other payment method, you create a Payment.  Payment can also be created without a payment method to initiate a payment process and redirect a customer to the hosted payment page.
     * @summary Create Payment
     * @param {CreatePaymentRequest} createPaymentRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    create: function (createPaymentRequest, options = {}) {
      try {
        function _temp10() {
          localVarHeaderParameter['Content-Type'] = 'application/json';
          localVarUrlObj.query = _extends({}, localVarUrlObj.query, localVarQueryParameter, options.query); // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943

          delete localVarUrlObj.search;
          let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
          localVarRequestOptions.headers = _extends({}, localVarHeaderParameter, headersFromBaseOptions, options.headers);
          const needsSerialization = typeof createPaymentRequest !== "string" || localVarRequestOptions.headers['Content-Type'] === 'application/json';
          localVarRequestOptions.data = needsSerialization ? JSON.stringify(createPaymentRequest !== undefined ? createPaymentRequest : {}) : createPaymentRequest || "";
          return {
            url: format(localVarUrlObj),
            options: localVarRequestOptions
          };
        }

        // verify required parameter 'createPaymentRequest' is not null or undefined
        if (createPaymentRequest === null || createPaymentRequest === undefined) {
          throw new RequiredError('createPaymentRequest', 'Required parameter createPaymentRequest was null or undefined when calling create.');
        }

        const localVarPath = `/payments`;
        const localVarUrlObj = parse(localVarPath, true);
        let baseOptions;

        if (configuration) {
          baseOptions = configuration.baseOptions;
        }

        const localVarRequestOptions = _extends({
          method: 'POST'
        }, baseOptions, options);

        const localVarHeaderParameter = {};
        const localVarQueryParameter = {}; // authentication APIKey required

        const _temp9 = function () {
          if (configuration && configuration.apiKey) {
            return Promise.resolve(typeof configuration.apiKey === 'function' ? configuration.apiKey("Authorization") : configuration.apiKey).then(function (localVarApiKeyValue) {
              localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            });
          }
        }();

        return Promise.resolve(_temp9 && _temp9.then ? _temp9.then(_temp10) : _temp10(_temp9));
      } catch (e) {
        return Promise.reject(e);
      }
    },

    /**
     * Get the details of a payment that has previously been created. Supply the unique payment ID that was returned from your previous request.
     * @summary Get Payment
     * @param {string} id The payment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    get: function (id, options = {}) {
      try {
        function _temp12() {
          localVarUrlObj.query = _extends({}, localVarUrlObj.query, localVarQueryParameter, options.query); // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943

          delete localVarUrlObj.search;
          let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
          localVarRequestOptions.headers = _extends({}, localVarHeaderParameter, headersFromBaseOptions, options.headers);
          return {
            url: format(localVarUrlObj),
            options: localVarRequestOptions
          };
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
          throw new RequiredError('id', 'Required parameter id was null or undefined when calling get.');
        }

        const localVarPath = `/payments/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
        const localVarUrlObj = parse(localVarPath, true);
        let baseOptions;

        if (configuration) {
          baseOptions = configuration.baseOptions;
        }

        const localVarRequestOptions = _extends({
          method: 'GET'
        }, baseOptions, options);

        const localVarHeaderParameter = {};
        const localVarQueryParameter = {}; // authentication APIKey required

        const _temp11 = function () {
          if (configuration && configuration.apiKey) {
            return Promise.resolve(typeof configuration.apiKey === 'function' ? configuration.apiKey("Authorization") : configuration.apiKey).then(function (localVarApiKeyValue) {
              localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            });
          }
        }();

        return Promise.resolve(_temp11 && _temp11.then ? _temp11.then(_temp12) : _temp12(_temp11));
      } catch (e) {
        return Promise.reject(e);
      }
    },

    /**
     * Creates a subsequent operation for a recurring payment, previously created. The specified amount will be charged to the same credit or debit card of the originally payment.  If amount is not specified, it will default to the same amount from the original payment.
     * @summary Recurring Payment
     * @param {string} sequenceId The sequence ID
     * @param {RecurringPaymentRequest} [recurringPaymentRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    recurring: function (sequenceId, recurringPaymentRequest, options = {}) {
      try {
        function _temp14() {
          localVarHeaderParameter['Content-Type'] = 'application/json';
          localVarUrlObj.query = _extends({}, localVarUrlObj.query, localVarQueryParameter, options.query); // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943

          delete localVarUrlObj.search;
          let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
          localVarRequestOptions.headers = _extends({}, localVarHeaderParameter, headersFromBaseOptions, options.headers);
          const needsSerialization = typeof recurringPaymentRequest !== "string" || localVarRequestOptions.headers['Content-Type'] === 'application/json';
          localVarRequestOptions.data = needsSerialization ? JSON.stringify(recurringPaymentRequest !== undefined ? recurringPaymentRequest : {}) : recurringPaymentRequest || "";
          return {
            url: format(localVarUrlObj),
            options: localVarRequestOptions
          };
        }

        // verify required parameter 'sequenceId' is not null or undefined
        if (sequenceId === null || sequenceId === undefined) {
          throw new RequiredError('sequenceId', 'Required parameter sequenceId was null or undefined when calling recurring.');
        }

        const localVarPath = `/payments/{sequenceId}/recurring`.replace(`{${"sequenceId"}}`, encodeURIComponent(String(sequenceId)));
        const localVarUrlObj = parse(localVarPath, true);
        let baseOptions;

        if (configuration) {
          baseOptions = configuration.baseOptions;
        }

        const localVarRequestOptions = _extends({
          method: 'POST'
        }, baseOptions, options);

        const localVarHeaderParameter = {};
        const localVarQueryParameter = {}; // authentication APIKey required

        const _temp13 = function () {
          if (configuration && configuration.apiKey) {
            return Promise.resolve(typeof configuration.apiKey === 'function' ? configuration.apiKey("Authorization") : configuration.apiKey).then(function (localVarApiKeyValue) {
              localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            });
          }
        }();

        return Promise.resolve(_temp13 && _temp13.then ? _temp13.then(_temp14) : _temp14(_temp13));
      } catch (e) {
        return Promise.reject(e);
      }
    },

    /**
     * Refund a payment that has previously been created but not yet refunded. Funds will be refunded to the credit or debit card that was originally charged.  You can optionally refund only part of a payment. You can do so multiple times, until the entire payment has been refunded.  Once entirely refunded, a payment can’t be refunded again. This method will throw an error when called on an already-refunded payment, or when trying to refund more money than is left on a payment.
     * @summary Refund Payment
     * @param {string} id The payment ID
     * @param {RefundPaymentRequest} [refundPaymentRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    refund: function (id, refundPaymentRequest, options = {}) {
      try {
        function _temp16() {
          localVarHeaderParameter['Content-Type'] = 'application/json';
          localVarUrlObj.query = _extends({}, localVarUrlObj.query, localVarQueryParameter, options.query); // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943

          delete localVarUrlObj.search;
          let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
          localVarRequestOptions.headers = _extends({}, localVarHeaderParameter, headersFromBaseOptions, options.headers);
          const needsSerialization = typeof refundPaymentRequest !== "string" || localVarRequestOptions.headers['Content-Type'] === 'application/json';
          localVarRequestOptions.data = needsSerialization ? JSON.stringify(refundPaymentRequest !== undefined ? refundPaymentRequest : {}) : refundPaymentRequest || "";
          return {
            url: format(localVarUrlObj),
            options: localVarRequestOptions
          };
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
          throw new RequiredError('id', 'Required parameter id was null or undefined when calling refund.');
        }

        const localVarPath = `/payments/{id}/refund`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
        const localVarUrlObj = parse(localVarPath, true);
        let baseOptions;

        if (configuration) {
          baseOptions = configuration.baseOptions;
        }

        const localVarRequestOptions = _extends({
          method: 'POST'
        }, baseOptions, options);

        const localVarHeaderParameter = {};
        const localVarQueryParameter = {}; // authentication APIKey required

        const _temp15 = function () {
          if (configuration && configuration.apiKey) {
            return Promise.resolve(typeof configuration.apiKey === 'function' ? configuration.apiKey("Authorization") : configuration.apiKey).then(function (localVarApiKeyValue) {
              localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            });
          }
        }();

        return Promise.resolve(_temp15 && _temp15.then ? _temp15.then(_temp16) : _temp16(_temp15));
      } catch (e) {
        return Promise.reject(e);
      }
    },

    /**
     * Sends a payment link to the customer. If payment has customer email, the link is sent via email. If payment has customer phone, the link is sent via WhatsApp, if the phone number is not registered in WhatsApp, the link is sent via SMS.
     * @summary Send Payment Link
     * @param {string} id The payment ID
     * @param {SendPaymentLinkRequest} [sendPaymentLinkRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendLink: function (id, sendPaymentLinkRequest, options = {}) {
      try {
        function _temp18() {
          localVarHeaderParameter['Content-Type'] = 'application/json';
          localVarUrlObj.query = _extends({}, localVarUrlObj.query, localVarQueryParameter, options.query); // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943

          delete localVarUrlObj.search;
          let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
          localVarRequestOptions.headers = _extends({}, localVarHeaderParameter, headersFromBaseOptions, options.headers);
          const needsSerialization = typeof sendPaymentLinkRequest !== "string" || localVarRequestOptions.headers['Content-Type'] === 'application/json';
          localVarRequestOptions.data = needsSerialization ? JSON.stringify(sendPaymentLinkRequest !== undefined ? sendPaymentLinkRequest : {}) : sendPaymentLinkRequest || "";
          return {
            url: format(localVarUrlObj),
            options: localVarRequestOptions
          };
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
          throw new RequiredError('id', 'Required parameter id was null or undefined when calling sendLink.');
        }

        const localVarPath = `/payments/{id}/link`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
        const localVarUrlObj = parse(localVarPath, true);
        let baseOptions;

        if (configuration) {
          baseOptions = configuration.baseOptions;
        }

        const localVarRequestOptions = _extends({
          method: 'POST'
        }, baseOptions, options);

        const localVarHeaderParameter = {};
        const localVarQueryParameter = {}; // authentication APIKey required

        const _temp17 = function () {
          if (configuration && configuration.apiKey) {
            return Promise.resolve(typeof configuration.apiKey === 'function' ? configuration.apiKey("Authorization") : configuration.apiKey).then(function (localVarApiKeyValue) {
              localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            });
          }
        }();

        return Promise.resolve(_temp17 && _temp17.then ? _temp17.then(_temp18) : _temp18(_temp17));
      } catch (e) {
        return Promise.reject(e);
      }
    },

    /**
     * Sends a payment receipt to the customer. If payment has customer email, the receipt is sent via email. If payment has customer phone, the receipt is sent via WhatsApp, if the phone number is not registered in WhatsApp, the receipt is sent via SMS.
     * @summary Send Payment Receipt
     * @param {string} id The payment ID
     * @param {SendPaymentReceiptRequest} [sendPaymentReceiptRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendReceipt: function (id, sendPaymentReceiptRequest, options = {}) {
      try {
        function _temp20() {
          localVarHeaderParameter['Content-Type'] = 'application/json';
          localVarUrlObj.query = _extends({}, localVarUrlObj.query, localVarQueryParameter, options.query); // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943

          delete localVarUrlObj.search;
          let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
          localVarRequestOptions.headers = _extends({}, localVarHeaderParameter, headersFromBaseOptions, options.headers);
          const needsSerialization = typeof sendPaymentReceiptRequest !== "string" || localVarRequestOptions.headers['Content-Type'] === 'application/json';
          localVarRequestOptions.data = needsSerialization ? JSON.stringify(sendPaymentReceiptRequest !== undefined ? sendPaymentReceiptRequest : {}) : sendPaymentReceiptRequest || "";
          return {
            url: format(localVarUrlObj),
            options: localVarRequestOptions
          };
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
          throw new RequiredError('id', 'Required parameter id was null or undefined when calling sendReceipt.');
        }

        const localVarPath = `/payments/{id}/receipt`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
        const localVarUrlObj = parse(localVarPath, true);
        let baseOptions;

        if (configuration) {
          baseOptions = configuration.baseOptions;
        }

        const localVarRequestOptions = _extends({
          method: 'POST'
        }, baseOptions, options);

        const localVarHeaderParameter = {};
        const localVarQueryParameter = {}; // authentication APIKey required

        const _temp19 = function () {
          if (configuration && configuration.apiKey) {
            return Promise.resolve(typeof configuration.apiKey === 'function' ? configuration.apiKey("Authorization") : configuration.apiKey).then(function (localVarApiKeyValue) {
              localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            });
          }
        }();

        return Promise.resolve(_temp19 && _temp19.then ? _temp19.then(_temp20) : _temp20(_temp19));
      } catch (e) {
        return Promise.reject(e);
      }
    },

    /**
     * Sends a payment request directly to the customer\'s phone. If Bizum payment method is available and the phone number is registered in Bizum, the customer will get a push notification to confirm the payment directly in the banking app, otherwise, he will receive a link to pay via WhatsApp.
     * @summary Send Payment Request
     * @param {string} id The payment ID
     * @param {SendPaymentRequest} sendPaymentRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendRequest: function (id, sendPaymentRequest, options = {}) {
      try {
        function _temp22() {
          localVarHeaderParameter['Content-Type'] = 'application/json';
          localVarUrlObj.query = _extends({}, localVarUrlObj.query, localVarQueryParameter, options.query); // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943

          delete localVarUrlObj.search;
          let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
          localVarRequestOptions.headers = _extends({}, localVarHeaderParameter, headersFromBaseOptions, options.headers);
          const needsSerialization = typeof sendPaymentRequest !== "string" || localVarRequestOptions.headers['Content-Type'] === 'application/json';
          localVarRequestOptions.data = needsSerialization ? JSON.stringify(sendPaymentRequest !== undefined ? sendPaymentRequest : {}) : sendPaymentRequest || "";
          return {
            url: format(localVarUrlObj),
            options: localVarRequestOptions
          };
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
          throw new RequiredError('id', 'Required parameter id was null or undefined when calling sendRequest.');
        } // verify required parameter 'sendPaymentRequest' is not null or undefined


        if (sendPaymentRequest === null || sendPaymentRequest === undefined) {
          throw new RequiredError('sendPaymentRequest', 'Required parameter sendPaymentRequest was null or undefined when calling sendRequest.');
        }

        const localVarPath = `/payments/{id}/rtp`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
        const localVarUrlObj = parse(localVarPath, true);
        let baseOptions;

        if (configuration) {
          baseOptions = configuration.baseOptions;
        }

        const localVarRequestOptions = _extends({
          method: 'POST'
        }, baseOptions, options);

        const localVarHeaderParameter = {};
        const localVarQueryParameter = {}; // authentication APIKey required

        const _temp21 = function () {
          if (configuration && configuration.apiKey) {
            return Promise.resolve(typeof configuration.apiKey === 'function' ? configuration.apiKey("Authorization") : configuration.apiKey).then(function (localVarApiKeyValue) {
              localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            });
          }
        }();

        return Promise.resolve(_temp21 && _temp21.then ? _temp21.then(_temp22) : _temp22(_temp21));
      } catch (e) {
        return Promise.reject(e);
      }
    }
  };
};
/**
 * PaymentsApi - functional programming interface
 * @export
 */

const PaymentsApiFp = function (configuration) {
  return {
    /**
     * Release customer\'s funds that were reserved earlier. You can only cancel a payment with the `AUTHORIZED` status.  This is the second half of the two-step payment flow, where first you created a payment with the `transactionType` set to `AUTH`.
     * @summary Cancel Payment
     * @param {string} id The payment ID
     * @param {CancelPaymentRequest} [cancelPaymentRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancel: function (id, cancelPaymentRequest, options) {
      try {
        return Promise.resolve(PaymentsApiAxiosParamCreator(configuration).cancel(id, cancelPaymentRequest, options)).then(function (localVarAxiosArgs) {
          return (axios = axios__default, basePath = BASE_PATH) => {
            const axiosRequestArgs = _extends({}, localVarAxiosArgs.options, {
              url: basePath + localVarAxiosArgs.url
            });

            return axios.request(axiosRequestArgs);
          };
        });
      } catch (e) {
        return Promise.reject(e);
      }
    },

    /**
     * Capture the payment of an existing, uncaptured, payment. This is the second half of the two-step payment flow, where first you created a payment with the `transactionType` set to `AUTH`.  Uncaptured payments expire exactly seven days after they are created. If they are not captured by that point in time, they will be marked as expired and will no longer be capturable.
     * @summary Capture Payment
     * @param {string} id The payment ID
     * @param {CapturePaymentRequest} [capturePaymentRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    capture: function (id, capturePaymentRequest, options) {
      try {
        return Promise.resolve(PaymentsApiAxiosParamCreator(configuration).capture(id, capturePaymentRequest, options)).then(function (localVarAxiosArgs) {
          return (axios = axios__default, basePath = BASE_PATH) => {
            const axiosRequestArgs = _extends({}, localVarAxiosArgs.options, {
              url: basePath + localVarAxiosArgs.url
            });

            return axios.request(axiosRequestArgs);
          };
        });
      } catch (e) {
        return Promise.reject(e);
      }
    },

    /**
     * Confirm a payment that was created without a `paymentToken` or `paymentMethod`. You can only confirm a payment with the `PENDING` status.  You can charge a customer in two steps. First create a payment without payment details and then confirm it after you generate a `paymentToken` on the front-end with monei.js [Components](https://docs.monei.com/docs/monei-js-overview).  You can provide additional customer information, it will override the information passed in **create payment** request.
     * @summary Confirm Payment
     * @param {string} id The payment ID
     * @param {ConfirmPaymentRequest} [confirmPaymentRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    confirm: function (id, confirmPaymentRequest, options) {
      try {
        return Promise.resolve(PaymentsApiAxiosParamCreator(configuration).confirm(id, confirmPaymentRequest, options)).then(function (localVarAxiosArgs) {
          return (axios = axios__default, basePath = BASE_PATH) => {
            const axiosRequestArgs = _extends({}, localVarAxiosArgs.options, {
              url: basePath + localVarAxiosArgs.url
            });

            return axios.request(axiosRequestArgs);
          };
        });
      } catch (e) {
        return Promise.reject(e);
      }
    },

    /**
     * To charge a credit card or other payment method, you create a Payment.  Payment can also be created without a payment method to initiate a payment process and redirect a customer to the hosted payment page.
     * @summary Create Payment
     * @param {CreatePaymentRequest} createPaymentRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    create: function (createPaymentRequest, options) {
      try {
        return Promise.resolve(PaymentsApiAxiosParamCreator(configuration).create(createPaymentRequest, options)).then(function (localVarAxiosArgs) {
          return (axios = axios__default, basePath = BASE_PATH) => {
            const axiosRequestArgs = _extends({}, localVarAxiosArgs.options, {
              url: basePath + localVarAxiosArgs.url
            });

            return axios.request(axiosRequestArgs);
          };
        });
      } catch (e) {
        return Promise.reject(e);
      }
    },

    /**
     * Get the details of a payment that has previously been created. Supply the unique payment ID that was returned from your previous request.
     * @summary Get Payment
     * @param {string} id The payment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    get: function (id, options) {
      try {
        return Promise.resolve(PaymentsApiAxiosParamCreator(configuration).get(id, options)).then(function (localVarAxiosArgs) {
          return (axios = axios__default, basePath = BASE_PATH) => {
            const axiosRequestArgs = _extends({}, localVarAxiosArgs.options, {
              url: basePath + localVarAxiosArgs.url
            });

            return axios.request(axiosRequestArgs);
          };
        });
      } catch (e) {
        return Promise.reject(e);
      }
    },

    /**
     * Creates a subsequent operation for a recurring payment, previously created. The specified amount will be charged to the same credit or debit card of the originally payment.  If amount is not specified, it will default to the same amount from the original payment.
     * @summary Recurring Payment
     * @param {string} sequenceId The sequence ID
     * @param {RecurringPaymentRequest} [recurringPaymentRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    recurring: function (sequenceId, recurringPaymentRequest, options) {
      try {
        return Promise.resolve(PaymentsApiAxiosParamCreator(configuration).recurring(sequenceId, recurringPaymentRequest, options)).then(function (localVarAxiosArgs) {
          return (axios = axios__default, basePath = BASE_PATH) => {
            const axiosRequestArgs = _extends({}, localVarAxiosArgs.options, {
              url: basePath + localVarAxiosArgs.url
            });

            return axios.request(axiosRequestArgs);
          };
        });
      } catch (e) {
        return Promise.reject(e);
      }
    },

    /**
     * Refund a payment that has previously been created but not yet refunded. Funds will be refunded to the credit or debit card that was originally charged.  You can optionally refund only part of a payment. You can do so multiple times, until the entire payment has been refunded.  Once entirely refunded, a payment can’t be refunded again. This method will throw an error when called on an already-refunded payment, or when trying to refund more money than is left on a payment.
     * @summary Refund Payment
     * @param {string} id The payment ID
     * @param {RefundPaymentRequest} [refundPaymentRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    refund: function (id, refundPaymentRequest, options) {
      try {
        return Promise.resolve(PaymentsApiAxiosParamCreator(configuration).refund(id, refundPaymentRequest, options)).then(function (localVarAxiosArgs) {
          return (axios = axios__default, basePath = BASE_PATH) => {
            const axiosRequestArgs = _extends({}, localVarAxiosArgs.options, {
              url: basePath + localVarAxiosArgs.url
            });

            return axios.request(axiosRequestArgs);
          };
        });
      } catch (e) {
        return Promise.reject(e);
      }
    },

    /**
     * Sends a payment link to the customer. If payment has customer email, the link is sent via email. If payment has customer phone, the link is sent via WhatsApp, if the phone number is not registered in WhatsApp, the link is sent via SMS.
     * @summary Send Payment Link
     * @param {string} id The payment ID
     * @param {SendPaymentLinkRequest} [sendPaymentLinkRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendLink: function (id, sendPaymentLinkRequest, options) {
      try {
        return Promise.resolve(PaymentsApiAxiosParamCreator(configuration).sendLink(id, sendPaymentLinkRequest, options)).then(function (localVarAxiosArgs) {
          return (axios = axios__default, basePath = BASE_PATH) => {
            const axiosRequestArgs = _extends({}, localVarAxiosArgs.options, {
              url: basePath + localVarAxiosArgs.url
            });

            return axios.request(axiosRequestArgs);
          };
        });
      } catch (e) {
        return Promise.reject(e);
      }
    },

    /**
     * Sends a payment receipt to the customer. If payment has customer email, the receipt is sent via email. If payment has customer phone, the receipt is sent via WhatsApp, if the phone number is not registered in WhatsApp, the receipt is sent via SMS.
     * @summary Send Payment Receipt
     * @param {string} id The payment ID
     * @param {SendPaymentReceiptRequest} [sendPaymentReceiptRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendReceipt: function (id, sendPaymentReceiptRequest, options) {
      try {
        return Promise.resolve(PaymentsApiAxiosParamCreator(configuration).sendReceipt(id, sendPaymentReceiptRequest, options)).then(function (localVarAxiosArgs) {
          return (axios = axios__default, basePath = BASE_PATH) => {
            const axiosRequestArgs = _extends({}, localVarAxiosArgs.options, {
              url: basePath + localVarAxiosArgs.url
            });

            return axios.request(axiosRequestArgs);
          };
        });
      } catch (e) {
        return Promise.reject(e);
      }
    },

    /**
     * Sends a payment request directly to the customer\'s phone. If Bizum payment method is available and the phone number is registered in Bizum, the customer will get a push notification to confirm the payment directly in the banking app, otherwise, he will receive a link to pay via WhatsApp.
     * @summary Send Payment Request
     * @param {string} id The payment ID
     * @param {SendPaymentRequest} sendPaymentRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendRequest: function (id, sendPaymentRequest, options) {
      try {
        return Promise.resolve(PaymentsApiAxiosParamCreator(configuration).sendRequest(id, sendPaymentRequest, options)).then(function (localVarAxiosArgs) {
          return (axios = axios__default, basePath = BASE_PATH) => {
            const axiosRequestArgs = _extends({}, localVarAxiosArgs.options, {
              url: basePath + localVarAxiosArgs.url
            });

            return axios.request(axiosRequestArgs);
          };
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
  };
};
/**
 * PaymentsApi - factory interface
 * @export
 */

const PaymentsApiFactory = function (configuration, basePath, axios) {
  return {
    /**
     * Release customer\'s funds that were reserved earlier. You can only cancel a payment with the `AUTHORIZED` status.  This is the second half of the two-step payment flow, where first you created a payment with the `transactionType` set to `AUTH`.
     * @summary Cancel Payment
     * @param {string} id The payment ID
     * @param {CancelPaymentRequest} [cancelPaymentRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancel(id, cancelPaymentRequest, options) {
      return PaymentsApiFp(configuration).cancel(id, cancelPaymentRequest, options).then(request => request(axios, basePath));
    },

    /**
     * Capture the payment of an existing, uncaptured, payment. This is the second half of the two-step payment flow, where first you created a payment with the `transactionType` set to `AUTH`.  Uncaptured payments expire exactly seven days after they are created. If they are not captured by that point in time, they will be marked as expired and will no longer be capturable.
     * @summary Capture Payment
     * @param {string} id The payment ID
     * @param {CapturePaymentRequest} [capturePaymentRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    capture(id, capturePaymentRequest, options) {
      return PaymentsApiFp(configuration).capture(id, capturePaymentRequest, options).then(request => request(axios, basePath));
    },

    /**
     * Confirm a payment that was created without a `paymentToken` or `paymentMethod`. You can only confirm a payment with the `PENDING` status.  You can charge a customer in two steps. First create a payment without payment details and then confirm it after you generate a `paymentToken` on the front-end with monei.js [Components](https://docs.monei.com/docs/monei-js-overview).  You can provide additional customer information, it will override the information passed in **create payment** request.
     * @summary Confirm Payment
     * @param {string} id The payment ID
     * @param {ConfirmPaymentRequest} [confirmPaymentRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    confirm(id, confirmPaymentRequest, options) {
      return PaymentsApiFp(configuration).confirm(id, confirmPaymentRequest, options).then(request => request(axios, basePath));
    },

    /**
     * To charge a credit card or other payment method, you create a Payment.  Payment can also be created without a payment method to initiate a payment process and redirect a customer to the hosted payment page.
     * @summary Create Payment
     * @param {CreatePaymentRequest} createPaymentRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    create(createPaymentRequest, options) {
      return PaymentsApiFp(configuration).create(createPaymentRequest, options).then(request => request(axios, basePath));
    },

    /**
     * Get the details of a payment that has previously been created. Supply the unique payment ID that was returned from your previous request.
     * @summary Get Payment
     * @param {string} id The payment ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    get(id, options) {
      return PaymentsApiFp(configuration).get(id, options).then(request => request(axios, basePath));
    },

    /**
     * Creates a subsequent operation for a recurring payment, previously created. The specified amount will be charged to the same credit or debit card of the originally payment.  If amount is not specified, it will default to the same amount from the original payment.
     * @summary Recurring Payment
     * @param {string} sequenceId The sequence ID
     * @param {RecurringPaymentRequest} [recurringPaymentRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    recurring(sequenceId, recurringPaymentRequest, options) {
      return PaymentsApiFp(configuration).recurring(sequenceId, recurringPaymentRequest, options).then(request => request(axios, basePath));
    },

    /**
     * Refund a payment that has previously been created but not yet refunded. Funds will be refunded to the credit or debit card that was originally charged.  You can optionally refund only part of a payment. You can do so multiple times, until the entire payment has been refunded.  Once entirely refunded, a payment can’t be refunded again. This method will throw an error when called on an already-refunded payment, or when trying to refund more money than is left on a payment.
     * @summary Refund Payment
     * @param {string} id The payment ID
     * @param {RefundPaymentRequest} [refundPaymentRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    refund(id, refundPaymentRequest, options) {
      return PaymentsApiFp(configuration).refund(id, refundPaymentRequest, options).then(request => request(axios, basePath));
    },

    /**
     * Sends a payment link to the customer. If payment has customer email, the link is sent via email. If payment has customer phone, the link is sent via WhatsApp, if the phone number is not registered in WhatsApp, the link is sent via SMS.
     * @summary Send Payment Link
     * @param {string} id The payment ID
     * @param {SendPaymentLinkRequest} [sendPaymentLinkRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendLink(id, sendPaymentLinkRequest, options) {
      return PaymentsApiFp(configuration).sendLink(id, sendPaymentLinkRequest, options).then(request => request(axios, basePath));
    },

    /**
     * Sends a payment receipt to the customer. If payment has customer email, the receipt is sent via email. If payment has customer phone, the receipt is sent via WhatsApp, if the phone number is not registered in WhatsApp, the receipt is sent via SMS.
     * @summary Send Payment Receipt
     * @param {string} id The payment ID
     * @param {SendPaymentReceiptRequest} [sendPaymentReceiptRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendReceipt(id, sendPaymentReceiptRequest, options) {
      return PaymentsApiFp(configuration).sendReceipt(id, sendPaymentReceiptRequest, options).then(request => request(axios, basePath));
    },

    /**
     * Sends a payment request directly to the customer\'s phone. If Bizum payment method is available and the phone number is registered in Bizum, the customer will get a push notification to confirm the payment directly in the banking app, otherwise, he will receive a link to pay via WhatsApp.
     * @summary Send Payment Request
     * @param {string} id The payment ID
     * @param {SendPaymentRequest} sendPaymentRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    sendRequest(id, sendPaymentRequest, options) {
      return PaymentsApiFp(configuration).sendRequest(id, sendPaymentRequest, options).then(request => request(axios, basePath));
    }

  };
};
/**
 * PaymentsApi - object-oriented interface
 * @export
 * @class PaymentsApi
 * @extends {BaseAPI}
 */

class PaymentsApi extends BaseAPI {
  /**
   * Release customer\'s funds that were reserved earlier. You can only cancel a payment with the `AUTHORIZED` status.  This is the second half of the two-step payment flow, where first you created a payment with the `transactionType` set to `AUTH`.
   * @summary Cancel Payment
   * @param {string} id The payment ID
   * @param {CancelPaymentRequest} [cancelPaymentRequest]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PaymentsApi
   */
  cancel(id, cancelPaymentRequest, options) {
    return PaymentsApiFp(this.configuration).cancel(id, cancelPaymentRequest, options).then(request => request(this.axios, this.basePath));
  }
  /**
   * Capture the payment of an existing, uncaptured, payment. This is the second half of the two-step payment flow, where first you created a payment with the `transactionType` set to `AUTH`.  Uncaptured payments expire exactly seven days after they are created. If they are not captured by that point in time, they will be marked as expired and will no longer be capturable.
   * @summary Capture Payment
   * @param {string} id The payment ID
   * @param {CapturePaymentRequest} [capturePaymentRequest]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PaymentsApi
   */


  capture(id, capturePaymentRequest, options) {
    return PaymentsApiFp(this.configuration).capture(id, capturePaymentRequest, options).then(request => request(this.axios, this.basePath));
  }
  /**
   * Confirm a payment that was created without a `paymentToken` or `paymentMethod`. You can only confirm a payment with the `PENDING` status.  You can charge a customer in two steps. First create a payment without payment details and then confirm it after you generate a `paymentToken` on the front-end with monei.js [Components](https://docs.monei.com/docs/monei-js-overview).  You can provide additional customer information, it will override the information passed in **create payment** request.
   * @summary Confirm Payment
   * @param {string} id The payment ID
   * @param {ConfirmPaymentRequest} [confirmPaymentRequest]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PaymentsApi
   */


  confirm(id, confirmPaymentRequest, options) {
    return PaymentsApiFp(this.configuration).confirm(id, confirmPaymentRequest, options).then(request => request(this.axios, this.basePath));
  }
  /**
   * To charge a credit card or other payment method, you create a Payment.  Payment can also be created without a payment method to initiate a payment process and redirect a customer to the hosted payment page.
   * @summary Create Payment
   * @param {CreatePaymentRequest} createPaymentRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PaymentsApi
   */


  create(createPaymentRequest, options) {
    return PaymentsApiFp(this.configuration).create(createPaymentRequest, options).then(request => request(this.axios, this.basePath));
  }
  /**
   * Get the details of a payment that has previously been created. Supply the unique payment ID that was returned from your previous request.
   * @summary Get Payment
   * @param {string} id The payment ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PaymentsApi
   */


  get(id, options) {
    return PaymentsApiFp(this.configuration).get(id, options).then(request => request(this.axios, this.basePath));
  }
  /**
   * Creates a subsequent operation for a recurring payment, previously created. The specified amount will be charged to the same credit or debit card of the originally payment.  If amount is not specified, it will default to the same amount from the original payment.
   * @summary Recurring Payment
   * @param {string} sequenceId The sequence ID
   * @param {RecurringPaymentRequest} [recurringPaymentRequest]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PaymentsApi
   */


  recurring(sequenceId, recurringPaymentRequest, options) {
    return PaymentsApiFp(this.configuration).recurring(sequenceId, recurringPaymentRequest, options).then(request => request(this.axios, this.basePath));
  }
  /**
   * Refund a payment that has previously been created but not yet refunded. Funds will be refunded to the credit or debit card that was originally charged.  You can optionally refund only part of a payment. You can do so multiple times, until the entire payment has been refunded.  Once entirely refunded, a payment can’t be refunded again. This method will throw an error when called on an already-refunded payment, or when trying to refund more money than is left on a payment.
   * @summary Refund Payment
   * @param {string} id The payment ID
   * @param {RefundPaymentRequest} [refundPaymentRequest]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PaymentsApi
   */


  refund(id, refundPaymentRequest, options) {
    return PaymentsApiFp(this.configuration).refund(id, refundPaymentRequest, options).then(request => request(this.axios, this.basePath));
  }
  /**
   * Sends a payment link to the customer. If payment has customer email, the link is sent via email. If payment has customer phone, the link is sent via WhatsApp, if the phone number is not registered in WhatsApp, the link is sent via SMS.
   * @summary Send Payment Link
   * @param {string} id The payment ID
   * @param {SendPaymentLinkRequest} [sendPaymentLinkRequest]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PaymentsApi
   */


  sendLink(id, sendPaymentLinkRequest, options) {
    return PaymentsApiFp(this.configuration).sendLink(id, sendPaymentLinkRequest, options).then(request => request(this.axios, this.basePath));
  }
  /**
   * Sends a payment receipt to the customer. If payment has customer email, the receipt is sent via email. If payment has customer phone, the receipt is sent via WhatsApp, if the phone number is not registered in WhatsApp, the receipt is sent via SMS.
   * @summary Send Payment Receipt
   * @param {string} id The payment ID
   * @param {SendPaymentReceiptRequest} [sendPaymentReceiptRequest]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PaymentsApi
   */


  sendReceipt(id, sendPaymentReceiptRequest, options) {
    return PaymentsApiFp(this.configuration).sendReceipt(id, sendPaymentReceiptRequest, options).then(request => request(this.axios, this.basePath));
  }
  /**
   * Sends a payment request directly to the customer\'s phone. If Bizum payment method is available and the phone number is registered in Bizum, the customer will get a push notification to confirm the payment directly in the banking app, otherwise, he will receive a link to pay via WhatsApp.
   * @summary Send Payment Request
   * @param {string} id The payment ID
   * @param {SendPaymentRequest} sendPaymentRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof PaymentsApi
   */


  sendRequest(id, sendPaymentRequest, options) {
    return PaymentsApiFp(this.configuration).sendRequest(id, sendPaymentRequest, options).then(request => request(this.axios, this.basePath));
  }

}
/**
 * SubscriptionsApi - axios parameter creator
 * @export
 */

const SubscriptionsApiAxiosParamCreator = function (configuration) {
  return {
    /**
     * Activates the subscription that was previously created. Activation of the subscription will create an initial payment. If the subscription has trial period, the initial payment will have zero amount. The subscription is automatically activated when initial payment is confirmed.  If the subscription is already activated, this endpoint can be used to update payment method. This will also generate zero amount payment.
     * @summary Activate Subscription
     * @param {string} id The subscription ID
     * @param {ActivateSubscriptionRequest} [activateSubscriptionRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    activate: function (id, activateSubscriptionRequest, options = {}) {
      try {
        function _temp24() {
          localVarHeaderParameter['Content-Type'] = 'application/json';
          localVarUrlObj.query = _extends({}, localVarUrlObj.query, localVarQueryParameter, options.query); // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943

          delete localVarUrlObj.search;
          let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
          localVarRequestOptions.headers = _extends({}, localVarHeaderParameter, headersFromBaseOptions, options.headers);
          const needsSerialization = typeof activateSubscriptionRequest !== "string" || localVarRequestOptions.headers['Content-Type'] === 'application/json';
          localVarRequestOptions.data = needsSerialization ? JSON.stringify(activateSubscriptionRequest !== undefined ? activateSubscriptionRequest : {}) : activateSubscriptionRequest || "";
          return {
            url: format(localVarUrlObj),
            options: localVarRequestOptions
          };
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
          throw new RequiredError('id', 'Required parameter id was null or undefined when calling activate.');
        }

        const localVarPath = `/subscriptions/{id}/activate`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
        const localVarUrlObj = parse(localVarPath, true);
        let baseOptions;

        if (configuration) {
          baseOptions = configuration.baseOptions;
        }

        const localVarRequestOptions = _extends({
          method: 'POST'
        }, baseOptions, options);

        const localVarHeaderParameter = {};
        const localVarQueryParameter = {}; // authentication APIKey required

        const _temp23 = function () {
          if (configuration && configuration.apiKey) {
            return Promise.resolve(typeof configuration.apiKey === 'function' ? configuration.apiKey("Authorization") : configuration.apiKey).then(function (localVarApiKeyValue) {
              localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            });
          }
        }();

        return Promise.resolve(_temp23 && _temp23.then ? _temp23.then(_temp24) : _temp24(_temp23));
      } catch (e) {
        return Promise.reject(e);
      }
    },

    /**
     * Cancels the activate subscription.
     * @summary Cancel Subscription
     * @param {string} id The subscription ID
     * @param {CancelSubscriptionRequest} [cancelSubscriptionRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancel: function (id, cancelSubscriptionRequest, options = {}) {
      try {
        function _temp26() {
          localVarHeaderParameter['Content-Type'] = 'application/json';
          localVarUrlObj.query = _extends({}, localVarUrlObj.query, localVarQueryParameter, options.query); // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943

          delete localVarUrlObj.search;
          let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
          localVarRequestOptions.headers = _extends({}, localVarHeaderParameter, headersFromBaseOptions, options.headers);
          const needsSerialization = typeof cancelSubscriptionRequest !== "string" || localVarRequestOptions.headers['Content-Type'] === 'application/json';
          localVarRequestOptions.data = needsSerialization ? JSON.stringify(cancelSubscriptionRequest !== undefined ? cancelSubscriptionRequest : {}) : cancelSubscriptionRequest || "";
          return {
            url: format(localVarUrlObj),
            options: localVarRequestOptions
          };
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
          throw new RequiredError('id', 'Required parameter id was null or undefined when calling cancel.');
        }

        const localVarPath = `/subscriptions/{id}/cancel`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
        const localVarUrlObj = parse(localVarPath, true);
        let baseOptions;

        if (configuration) {
          baseOptions = configuration.baseOptions;
        }

        const localVarRequestOptions = _extends({
          method: 'POST'
        }, baseOptions, options);

        const localVarHeaderParameter = {};
        const localVarQueryParameter = {}; // authentication APIKey required

        const _temp25 = function () {
          if (configuration && configuration.apiKey) {
            return Promise.resolve(typeof configuration.apiKey === 'function' ? configuration.apiKey("Authorization") : configuration.apiKey).then(function (localVarApiKeyValue) {
              localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            });
          }
        }();

        return Promise.resolve(_temp25 && _temp25.then ? _temp25.then(_temp26) : _temp26(_temp25));
      } catch (e) {
        return Promise.reject(e);
      }
    },

    /**
     * Creates a new subscription. Subscription is created with status: `PENDING`. In order to activate it you need to call [activate endpoint](#operation/subscriptions_activate).
     * @summary Create Subscription
     * @param {CreateSubscriptionRequest} createSubscriptionRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    create: function (createSubscriptionRequest, options = {}) {
      try {
        function _temp28() {
          localVarHeaderParameter['Content-Type'] = 'application/json';
          localVarUrlObj.query = _extends({}, localVarUrlObj.query, localVarQueryParameter, options.query); // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943

          delete localVarUrlObj.search;
          let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
          localVarRequestOptions.headers = _extends({}, localVarHeaderParameter, headersFromBaseOptions, options.headers);
          const needsSerialization = typeof createSubscriptionRequest !== "string" || localVarRequestOptions.headers['Content-Type'] === 'application/json';
          localVarRequestOptions.data = needsSerialization ? JSON.stringify(createSubscriptionRequest !== undefined ? createSubscriptionRequest : {}) : createSubscriptionRequest || "";
          return {
            url: format(localVarUrlObj),
            options: localVarRequestOptions
          };
        }

        // verify required parameter 'createSubscriptionRequest' is not null or undefined
        if (createSubscriptionRequest === null || createSubscriptionRequest === undefined) {
          throw new RequiredError('createSubscriptionRequest', 'Required parameter createSubscriptionRequest was null or undefined when calling create.');
        }

        const localVarPath = `/subscriptions`;
        const localVarUrlObj = parse(localVarPath, true);
        let baseOptions;

        if (configuration) {
          baseOptions = configuration.baseOptions;
        }

        const localVarRequestOptions = _extends({
          method: 'POST'
        }, baseOptions, options);

        const localVarHeaderParameter = {};
        const localVarQueryParameter = {}; // authentication APIKey required

        const _temp27 = function () {
          if (configuration && configuration.apiKey) {
            return Promise.resolve(typeof configuration.apiKey === 'function' ? configuration.apiKey("Authorization") : configuration.apiKey).then(function (localVarApiKeyValue) {
              localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            });
          }
        }();

        return Promise.resolve(_temp27 && _temp27.then ? _temp27.then(_temp28) : _temp28(_temp27));
      } catch (e) {
        return Promise.reject(e);
      }
    },

    /**
     * Get the details of a subscription that has previously been created. Supply the unique subscription ID that was returned from your previous request.
     * @summary Get Subscription
     * @param {string} id The subscription ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    get: function (id, options = {}) {
      try {
        function _temp30() {
          localVarUrlObj.query = _extends({}, localVarUrlObj.query, localVarQueryParameter, options.query); // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943

          delete localVarUrlObj.search;
          let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
          localVarRequestOptions.headers = _extends({}, localVarHeaderParameter, headersFromBaseOptions, options.headers);
          return {
            url: format(localVarUrlObj),
            options: localVarRequestOptions
          };
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
          throw new RequiredError('id', 'Required parameter id was null or undefined when calling get.');
        }

        const localVarPath = `/subscriptions/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
        const localVarUrlObj = parse(localVarPath, true);
        let baseOptions;

        if (configuration) {
          baseOptions = configuration.baseOptions;
        }

        const localVarRequestOptions = _extends({
          method: 'GET'
        }, baseOptions, options);

        const localVarHeaderParameter = {};
        const localVarQueryParameter = {}; // authentication APIKey required

        const _temp29 = function () {
          if (configuration && configuration.apiKey) {
            return Promise.resolve(typeof configuration.apiKey === 'function' ? configuration.apiKey("Authorization") : configuration.apiKey).then(function (localVarApiKeyValue) {
              localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            });
          }
        }();

        return Promise.resolve(_temp29 && _temp29.then ? _temp29.then(_temp30) : _temp30(_temp29));
      } catch (e) {
        return Promise.reject(e);
      }
    },

    /**
     * Pauses the active subscription.
     * @summary Pause Subscription
     * @param {string} id The subscription ID
     * @param {PauseSubscriptionRequest} [pauseSubscriptionRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    pause: function (id, pauseSubscriptionRequest, options = {}) {
      try {
        function _temp32() {
          localVarHeaderParameter['Content-Type'] = 'application/json';
          localVarUrlObj.query = _extends({}, localVarUrlObj.query, localVarQueryParameter, options.query); // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943

          delete localVarUrlObj.search;
          let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
          localVarRequestOptions.headers = _extends({}, localVarHeaderParameter, headersFromBaseOptions, options.headers);
          const needsSerialization = typeof pauseSubscriptionRequest !== "string" || localVarRequestOptions.headers['Content-Type'] === 'application/json';
          localVarRequestOptions.data = needsSerialization ? JSON.stringify(pauseSubscriptionRequest !== undefined ? pauseSubscriptionRequest : {}) : pauseSubscriptionRequest || "";
          return {
            url: format(localVarUrlObj),
            options: localVarRequestOptions
          };
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
          throw new RequiredError('id', 'Required parameter id was null or undefined when calling pause.');
        }

        const localVarPath = `/subscriptions/{id}/pause`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
        const localVarUrlObj = parse(localVarPath, true);
        let baseOptions;

        if (configuration) {
          baseOptions = configuration.baseOptions;
        }

        const localVarRequestOptions = _extends({
          method: 'POST'
        }, baseOptions, options);

        const localVarHeaderParameter = {};
        const localVarQueryParameter = {}; // authentication APIKey required

        const _temp31 = function () {
          if (configuration && configuration.apiKey) {
            return Promise.resolve(typeof configuration.apiKey === 'function' ? configuration.apiKey("Authorization") : configuration.apiKey).then(function (localVarApiKeyValue) {
              localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            });
          }
        }();

        return Promise.resolve(_temp31 && _temp31.then ? _temp31.then(_temp32) : _temp32(_temp31));
      } catch (e) {
        return Promise.reject(e);
      }
    },

    /**
     * Resumes the paused subscription.
     * @summary Resume Subscription
     * @param {string} id The subscription ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resume: function (id, options = {}) {
      try {
        function _temp34() {
          localVarUrlObj.query = _extends({}, localVarUrlObj.query, localVarQueryParameter, options.query); // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943

          delete localVarUrlObj.search;
          let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
          localVarRequestOptions.headers = _extends({}, localVarHeaderParameter, headersFromBaseOptions, options.headers);
          return {
            url: format(localVarUrlObj),
            options: localVarRequestOptions
          };
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
          throw new RequiredError('id', 'Required parameter id was null or undefined when calling resume.');
        }

        const localVarPath = `/subscriptions/{id}/resume`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
        const localVarUrlObj = parse(localVarPath, true);
        let baseOptions;

        if (configuration) {
          baseOptions = configuration.baseOptions;
        }

        const localVarRequestOptions = _extends({
          method: 'POST'
        }, baseOptions, options);

        const localVarHeaderParameter = {};
        const localVarQueryParameter = {}; // authentication APIKey required

        const _temp33 = function () {
          if (configuration && configuration.apiKey) {
            return Promise.resolve(typeof configuration.apiKey === 'function' ? configuration.apiKey("Authorization") : configuration.apiKey).then(function (localVarApiKeyValue) {
              localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            });
          }
        }();

        return Promise.resolve(_temp33 && _temp33.then ? _temp33.then(_temp34) : _temp34(_temp33));
      } catch (e) {
        return Promise.reject(e);
      }
    },

    /**
     * Updates an existing subscription. Supply the unique subscription ID that was returned from your previous request.
     * @summary Update Subscription
     * @param {string} id The subscription ID
     * @param {UpdateSubscriptionRequest} updateSubscriptionRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    update: function (id, updateSubscriptionRequest, options = {}) {
      try {
        function _temp36() {
          localVarHeaderParameter['Content-Type'] = 'application/json';
          localVarUrlObj.query = _extends({}, localVarUrlObj.query, localVarQueryParameter, options.query); // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943

          delete localVarUrlObj.search;
          let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
          localVarRequestOptions.headers = _extends({}, localVarHeaderParameter, headersFromBaseOptions, options.headers);
          const needsSerialization = typeof updateSubscriptionRequest !== "string" || localVarRequestOptions.headers['Content-Type'] === 'application/json';
          localVarRequestOptions.data = needsSerialization ? JSON.stringify(updateSubscriptionRequest !== undefined ? updateSubscriptionRequest : {}) : updateSubscriptionRequest || "";
          return {
            url: format(localVarUrlObj),
            options: localVarRequestOptions
          };
        }

        // verify required parameter 'id' is not null or undefined
        if (id === null || id === undefined) {
          throw new RequiredError('id', 'Required parameter id was null or undefined when calling update.');
        } // verify required parameter 'updateSubscriptionRequest' is not null or undefined


        if (updateSubscriptionRequest === null || updateSubscriptionRequest === undefined) {
          throw new RequiredError('updateSubscriptionRequest', 'Required parameter updateSubscriptionRequest was null or undefined when calling update.');
        }

        const localVarPath = `/subscriptions/{id}`.replace(`{${"id"}}`, encodeURIComponent(String(id)));
        const localVarUrlObj = parse(localVarPath, true);
        let baseOptions;

        if (configuration) {
          baseOptions = configuration.baseOptions;
        }

        const localVarRequestOptions = _extends({
          method: 'PUT'
        }, baseOptions, options);

        const localVarHeaderParameter = {};
        const localVarQueryParameter = {}; // authentication APIKey required

        const _temp35 = function () {
          if (configuration && configuration.apiKey) {
            return Promise.resolve(typeof configuration.apiKey === 'function' ? configuration.apiKey("Authorization") : configuration.apiKey).then(function (localVarApiKeyValue) {
              localVarHeaderParameter["Authorization"] = localVarApiKeyValue;
            });
          }
        }();

        return Promise.resolve(_temp35 && _temp35.then ? _temp35.then(_temp36) : _temp36(_temp35));
      } catch (e) {
        return Promise.reject(e);
      }
    }
  };
};
/**
 * SubscriptionsApi - functional programming interface
 * @export
 */

const SubscriptionsApiFp = function (configuration) {
  return {
    /**
     * Activates the subscription that was previously created. Activation of the subscription will create an initial payment. If the subscription has trial period, the initial payment will have zero amount. The subscription is automatically activated when initial payment is confirmed.  If the subscription is already activated, this endpoint can be used to update payment method. This will also generate zero amount payment.
     * @summary Activate Subscription
     * @param {string} id The subscription ID
     * @param {ActivateSubscriptionRequest} [activateSubscriptionRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    activate: function (id, activateSubscriptionRequest, options) {
      try {
        return Promise.resolve(SubscriptionsApiAxiosParamCreator(configuration).activate(id, activateSubscriptionRequest, options)).then(function (localVarAxiosArgs) {
          return (axios = axios__default, basePath = BASE_PATH) => {
            const axiosRequestArgs = _extends({}, localVarAxiosArgs.options, {
              url: basePath + localVarAxiosArgs.url
            });

            return axios.request(axiosRequestArgs);
          };
        });
      } catch (e) {
        return Promise.reject(e);
      }
    },

    /**
     * Cancels the activate subscription.
     * @summary Cancel Subscription
     * @param {string} id The subscription ID
     * @param {CancelSubscriptionRequest} [cancelSubscriptionRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancel: function (id, cancelSubscriptionRequest, options) {
      try {
        return Promise.resolve(SubscriptionsApiAxiosParamCreator(configuration).cancel(id, cancelSubscriptionRequest, options)).then(function (localVarAxiosArgs) {
          return (axios = axios__default, basePath = BASE_PATH) => {
            const axiosRequestArgs = _extends({}, localVarAxiosArgs.options, {
              url: basePath + localVarAxiosArgs.url
            });

            return axios.request(axiosRequestArgs);
          };
        });
      } catch (e) {
        return Promise.reject(e);
      }
    },

    /**
     * Creates a new subscription. Subscription is created with status: `PENDING`. In order to activate it you need to call [activate endpoint](#operation/subscriptions_activate).
     * @summary Create Subscription
     * @param {CreateSubscriptionRequest} createSubscriptionRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    create: function (createSubscriptionRequest, options) {
      try {
        return Promise.resolve(SubscriptionsApiAxiosParamCreator(configuration).create(createSubscriptionRequest, options)).then(function (localVarAxiosArgs) {
          return (axios = axios__default, basePath = BASE_PATH) => {
            const axiosRequestArgs = _extends({}, localVarAxiosArgs.options, {
              url: basePath + localVarAxiosArgs.url
            });

            return axios.request(axiosRequestArgs);
          };
        });
      } catch (e) {
        return Promise.reject(e);
      }
    },

    /**
     * Get the details of a subscription that has previously been created. Supply the unique subscription ID that was returned from your previous request.
     * @summary Get Subscription
     * @param {string} id The subscription ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    get: function (id, options) {
      try {
        return Promise.resolve(SubscriptionsApiAxiosParamCreator(configuration).get(id, options)).then(function (localVarAxiosArgs) {
          return (axios = axios__default, basePath = BASE_PATH) => {
            const axiosRequestArgs = _extends({}, localVarAxiosArgs.options, {
              url: basePath + localVarAxiosArgs.url
            });

            return axios.request(axiosRequestArgs);
          };
        });
      } catch (e) {
        return Promise.reject(e);
      }
    },

    /**
     * Pauses the active subscription.
     * @summary Pause Subscription
     * @param {string} id The subscription ID
     * @param {PauseSubscriptionRequest} [pauseSubscriptionRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    pause: function (id, pauseSubscriptionRequest, options) {
      try {
        return Promise.resolve(SubscriptionsApiAxiosParamCreator(configuration).pause(id, pauseSubscriptionRequest, options)).then(function (localVarAxiosArgs) {
          return (axios = axios__default, basePath = BASE_PATH) => {
            const axiosRequestArgs = _extends({}, localVarAxiosArgs.options, {
              url: basePath + localVarAxiosArgs.url
            });

            return axios.request(axiosRequestArgs);
          };
        });
      } catch (e) {
        return Promise.reject(e);
      }
    },

    /**
     * Resumes the paused subscription.
     * @summary Resume Subscription
     * @param {string} id The subscription ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resume: function (id, options) {
      try {
        return Promise.resolve(SubscriptionsApiAxiosParamCreator(configuration).resume(id, options)).then(function (localVarAxiosArgs) {
          return (axios = axios__default, basePath = BASE_PATH) => {
            const axiosRequestArgs = _extends({}, localVarAxiosArgs.options, {
              url: basePath + localVarAxiosArgs.url
            });

            return axios.request(axiosRequestArgs);
          };
        });
      } catch (e) {
        return Promise.reject(e);
      }
    },

    /**
     * Updates an existing subscription. Supply the unique subscription ID that was returned from your previous request.
     * @summary Update Subscription
     * @param {string} id The subscription ID
     * @param {UpdateSubscriptionRequest} updateSubscriptionRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    update: function (id, updateSubscriptionRequest, options) {
      try {
        return Promise.resolve(SubscriptionsApiAxiosParamCreator(configuration).update(id, updateSubscriptionRequest, options)).then(function (localVarAxiosArgs) {
          return (axios = axios__default, basePath = BASE_PATH) => {
            const axiosRequestArgs = _extends({}, localVarAxiosArgs.options, {
              url: basePath + localVarAxiosArgs.url
            });

            return axios.request(axiosRequestArgs);
          };
        });
      } catch (e) {
        return Promise.reject(e);
      }
    }
  };
};
/**
 * SubscriptionsApi - factory interface
 * @export
 */

const SubscriptionsApiFactory = function (configuration, basePath, axios) {
  return {
    /**
     * Activates the subscription that was previously created. Activation of the subscription will create an initial payment. If the subscription has trial period, the initial payment will have zero amount. The subscription is automatically activated when initial payment is confirmed.  If the subscription is already activated, this endpoint can be used to update payment method. This will also generate zero amount payment.
     * @summary Activate Subscription
     * @param {string} id The subscription ID
     * @param {ActivateSubscriptionRequest} [activateSubscriptionRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    activate(id, activateSubscriptionRequest, options) {
      return SubscriptionsApiFp(configuration).activate(id, activateSubscriptionRequest, options).then(request => request(axios, basePath));
    },

    /**
     * Cancels the activate subscription.
     * @summary Cancel Subscription
     * @param {string} id The subscription ID
     * @param {CancelSubscriptionRequest} [cancelSubscriptionRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    cancel(id, cancelSubscriptionRequest, options) {
      return SubscriptionsApiFp(configuration).cancel(id, cancelSubscriptionRequest, options).then(request => request(axios, basePath));
    },

    /**
     * Creates a new subscription. Subscription is created with status: `PENDING`. In order to activate it you need to call [activate endpoint](#operation/subscriptions_activate).
     * @summary Create Subscription
     * @param {CreateSubscriptionRequest} createSubscriptionRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    create(createSubscriptionRequest, options) {
      return SubscriptionsApiFp(configuration).create(createSubscriptionRequest, options).then(request => request(axios, basePath));
    },

    /**
     * Get the details of a subscription that has previously been created. Supply the unique subscription ID that was returned from your previous request.
     * @summary Get Subscription
     * @param {string} id The subscription ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    get(id, options) {
      return SubscriptionsApiFp(configuration).get(id, options).then(request => request(axios, basePath));
    },

    /**
     * Pauses the active subscription.
     * @summary Pause Subscription
     * @param {string} id The subscription ID
     * @param {PauseSubscriptionRequest} [pauseSubscriptionRequest]
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    pause(id, pauseSubscriptionRequest, options) {
      return SubscriptionsApiFp(configuration).pause(id, pauseSubscriptionRequest, options).then(request => request(axios, basePath));
    },

    /**
     * Resumes the paused subscription.
     * @summary Resume Subscription
     * @param {string} id The subscription ID
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    resume(id, options) {
      return SubscriptionsApiFp(configuration).resume(id, options).then(request => request(axios, basePath));
    },

    /**
     * Updates an existing subscription. Supply the unique subscription ID that was returned from your previous request.
     * @summary Update Subscription
     * @param {string} id The subscription ID
     * @param {UpdateSubscriptionRequest} updateSubscriptionRequest
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    update(id, updateSubscriptionRequest, options) {
      return SubscriptionsApiFp(configuration).update(id, updateSubscriptionRequest, options).then(request => request(axios, basePath));
    }

  };
};
/**
 * SubscriptionsApi - object-oriented interface
 * @export
 * @class SubscriptionsApi
 * @extends {BaseAPI}
 */

class SubscriptionsApi extends BaseAPI {
  /**
   * Activates the subscription that was previously created. Activation of the subscription will create an initial payment. If the subscription has trial period, the initial payment will have zero amount. The subscription is automatically activated when initial payment is confirmed.  If the subscription is already activated, this endpoint can be used to update payment method. This will also generate zero amount payment.
   * @summary Activate Subscription
   * @param {string} id The subscription ID
   * @param {ActivateSubscriptionRequest} [activateSubscriptionRequest]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SubscriptionsApi
   */
  activate(id, activateSubscriptionRequest, options) {
    return SubscriptionsApiFp(this.configuration).activate(id, activateSubscriptionRequest, options).then(request => request(this.axios, this.basePath));
  }
  /**
   * Cancels the activate subscription.
   * @summary Cancel Subscription
   * @param {string} id The subscription ID
   * @param {CancelSubscriptionRequest} [cancelSubscriptionRequest]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SubscriptionsApi
   */


  cancel(id, cancelSubscriptionRequest, options) {
    return SubscriptionsApiFp(this.configuration).cancel(id, cancelSubscriptionRequest, options).then(request => request(this.axios, this.basePath));
  }
  /**
   * Creates a new subscription. Subscription is created with status: `PENDING`. In order to activate it you need to call [activate endpoint](#operation/subscriptions_activate).
   * @summary Create Subscription
   * @param {CreateSubscriptionRequest} createSubscriptionRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SubscriptionsApi
   */


  create(createSubscriptionRequest, options) {
    return SubscriptionsApiFp(this.configuration).create(createSubscriptionRequest, options).then(request => request(this.axios, this.basePath));
  }
  /**
   * Get the details of a subscription that has previously been created. Supply the unique subscription ID that was returned from your previous request.
   * @summary Get Subscription
   * @param {string} id The subscription ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SubscriptionsApi
   */


  get(id, options) {
    return SubscriptionsApiFp(this.configuration).get(id, options).then(request => request(this.axios, this.basePath));
  }
  /**
   * Pauses the active subscription.
   * @summary Pause Subscription
   * @param {string} id The subscription ID
   * @param {PauseSubscriptionRequest} [pauseSubscriptionRequest]
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SubscriptionsApi
   */


  pause(id, pauseSubscriptionRequest, options) {
    return SubscriptionsApiFp(this.configuration).pause(id, pauseSubscriptionRequest, options).then(request => request(this.axios, this.basePath));
  }
  /**
   * Resumes the paused subscription.
   * @summary Resume Subscription
   * @param {string} id The subscription ID
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SubscriptionsApi
   */


  resume(id, options) {
    return SubscriptionsApiFp(this.configuration).resume(id, options).then(request => request(this.axios, this.basePath));
  }
  /**
   * Updates an existing subscription. Supply the unique subscription ID that was returned from your previous request.
   * @summary Update Subscription
   * @param {string} id The subscription ID
   * @param {UpdateSubscriptionRequest} updateSubscriptionRequest
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof SubscriptionsApi
   */


  update(id, updateSubscriptionRequest, options) {
    return SubscriptionsApiFp(this.configuration).update(id, updateSubscriptionRequest, options).then(request => request(this.axios, this.basePath));
  }

}

// tslint:disable

/**
 * MONEI API v1
 * <p>The MONEI API is organized around <a href=\"https://en.wikipedia.org/wiki/Representational_State_Transfer\">REST</a>. Our API has predictable resource-oriented URLs, accepts JSON-encoded request bodies, returns JSON-encoded responses, and uses standard HTTP response codes, authentication, and verbs.</p> <h4 id=\"base-url\">Base URL:</h4> <p><a href=\"https://api.monei.com/v1\">https://api.monei.com/v1</a></p> <h4 id=\"client-libraries\">Client libraries:</h4> <ul> <li><a href=\"https://github.com/MONEI/monei-php-sdk\">PHP SDK</a></li> <li><a href=\"https://github.com/MONEI/monei-python-sdk\">Python SDK</a></li> <li><a href=\"https://github.com/MONEI/monei-node-sdk\">Node.js SDK</a></li> <li><a href=\"https://postman.monei.com/\">Postman</a></li> </ul> <h4 id=\"important\">Important:</h4> <p><strong>If you are not using our official SDKs, you need to provide a valid <code>User-Agent</code> header in each request, otherwise your requests will be rejected.</strong></p>
 *
 * The version of the OpenAPI document: 1.4.4
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
class Configuration {
  constructor(param = {}) {
    this.apiKey = param.apiKey;
    this.username = param.username;
    this.password = param.password;
    this.accessToken = param.accessToken;
    this.basePath = param.basePath;
    this.baseOptions = param.baseOptions;
  }

}

class ServerError extends Error {
  constructor(res) {
    super(res.message);
    this.status = res.status;
    this.statusCode = res.statusCode;
    this.requestId = res.requestId;
    this.requestTime = new Date(res.requestTime);
  }

}

const responseHandler = res => {
  return res.data;
};

const errorHandler = error => {
  var _error$response;

  if (error == null ? void 0 : (_error$response = error.response) == null ? void 0 : _error$response.data) {
    throw new ServerError(error.response.data);
  }

  throw new Error('Something when wrong');
};

class Monei {
  constructor(apiKey, baseOptions) {
    this.client = axios__default.create();
    this.client.interceptors.response.use(responseHandler, errorHandler);
    this.client.defaults.headers.common['User-Agent'] = `MONEI/Node/${pkg.version}`;
    this.apiKey = apiKey;
    this.payments = new PaymentsApi({
      apiKey,
      baseOptions
    }, BASE_PATH, this.client);
    this.subscriptions = new SubscriptionsApi({
      apiKey,
      baseOptions
    }, BASE_PATH, this.client);
    this.applePayDomain = new ApplePayDomainApi({
      apiKey,
      baseOptions
    }, BASE_PATH, this.client);
  }

  verifySignature(body, signature) {
    const parts = signature.split(',').reduce((result, part) => {
      const [key, value] = part.split('=');
      result[key] = value;
      return result;
    }, {});
    const hmac = crypto.createHmac('SHA256', this.apiKey).update(`${parts.t}.${body}`).digest('hex');

    if (hmac !== parts.v1) {
      throw new Error('Signature verification failed.');
    }

    return JSON.parse(body);
  }

}

export { ApplePayDomainApi, ApplePayDomainApiAxiosParamCreator, ApplePayDomainApiFactory, ApplePayDomainApiFp, BizumApi, BizumApiAxiosParamCreator, BizumApiFactory, BizumApiFp, Configuration, Monei, PaymentCancellationReason, PaymentLastRefundReason, PaymentMessageChannel, PaymentMessageLanguage, PaymentNextActionTypeEnum, PaymentPaymentMethodCardBrandEnum, PaymentPaymentMethodCardThreeDSecureFlowEnum, PaymentPaymentMethodCardTokenizationMethodEnum, PaymentPaymentMethodCardTypeEnum, PaymentPaymentMethodKlarnaAuthPaymentMethodEnum, PaymentPaymentMethodKlarnaBillingCategoryEnum, PaymentPaymentMethodMethodEnum, PaymentRefundReason, PaymentSequenceTypeEnum, PaymentStatus, PaymentTransactionType, PaymentsApi, PaymentsApiAxiosParamCreator, PaymentsApiFactory, PaymentsApiFp, SubscriptionInterval, SubscriptionPaymentMethodCardBrandEnum, SubscriptionPaymentMethodCardTypeEnum, SubscriptionPaymentMethodMethodEnum, SubscriptionStatus, SubscriptionsApi, SubscriptionsApiAxiosParamCreator, SubscriptionsApiFactory, SubscriptionsApiFp };
//# sourceMappingURL=monei.module.js.map
